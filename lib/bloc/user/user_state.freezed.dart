// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'user_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$UserStateTearOff {
  const _$UserStateTearOff();

  _UserState call() {
    return const _UserState();
  }

  UserLoading loading() {
    return const UserLoading();
  }

  UserLogged logged() {
    return const UserLogged();
  }

  PasswordUpdated passwordUpdated() {
    return const PasswordUpdated();
  }

  UserError error({String? error, List<String>? errors, Object? data}) {
    return UserError(
      error: error,
      errors: errors,
      data: data,
    );
  }
}

/// @nodoc
const $UserState = _$UserStateTearOff();

/// @nodoc
mixin _$UserState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() loading,
    required TResult Function() logged,
    required TResult Function() passwordUpdated,
    required TResult Function(String? error, List<String>? errors, Object? data)
        error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UserState value) $default, {
    required TResult Function(UserLoading value) loading,
    required TResult Function(UserLogged value) logged,
    required TResult Function(PasswordUpdated value) passwordUpdated,
    required TResult Function(UserError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(_UserState value)? $default, {
    TResult Function(UserLoading value)? loading,
    TResult Function(UserLogged value)? logged,
    TResult Function(PasswordUpdated value)? passwordUpdated,
    TResult Function(UserError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UserState value)? $default, {
    TResult Function(UserLoading value)? loading,
    TResult Function(UserLogged value)? logged,
    TResult Function(PasswordUpdated value)? passwordUpdated,
    TResult Function(UserError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserStateCopyWith<$Res> {
  factory $UserStateCopyWith(UserState value, $Res Function(UserState) then) =
      _$UserStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserStateCopyWithImpl<$Res> implements $UserStateCopyWith<$Res> {
  _$UserStateCopyWithImpl(this._value, this._then);

  final UserState _value;
  // ignore: unused_field
  final $Res Function(UserState) _then;
}

/// @nodoc
abstract class _$UserStateCopyWith<$Res> {
  factory _$UserStateCopyWith(
          _UserState value, $Res Function(_UserState) then) =
      __$UserStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$UserStateCopyWithImpl<$Res> extends _$UserStateCopyWithImpl<$Res>
    implements _$UserStateCopyWith<$Res> {
  __$UserStateCopyWithImpl(_UserState _value, $Res Function(_UserState) _then)
      : super(_value, (v) => _then(v as _UserState));

  @override
  _UserState get _value => super._value as _UserState;
}

/// @nodoc

class _$_UserState implements _UserState {
  const _$_UserState();

  @override
  String toString() {
    return 'UserState()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _UserState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() loading,
    required TResult Function() logged,
    required TResult Function() passwordUpdated,
    required TResult Function(String? error, List<String>? errors, Object? data)
        error,
  }) {
    return $default();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
  }) {
    return $default?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UserState value) $default, {
    required TResult Function(UserLoading value) loading,
    required TResult Function(UserLogged value) logged,
    required TResult Function(PasswordUpdated value) passwordUpdated,
    required TResult Function(UserError value) error,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(_UserState value)? $default, {
    TResult Function(UserLoading value)? loading,
    TResult Function(UserLogged value)? logged,
    TResult Function(PasswordUpdated value)? passwordUpdated,
    TResult Function(UserError value)? error,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UserState value)? $default, {
    TResult Function(UserLoading value)? loading,
    TResult Function(UserLogged value)? logged,
    TResult Function(PasswordUpdated value)? passwordUpdated,
    TResult Function(UserError value)? error,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }
}

abstract class _UserState implements UserState {
  const factory _UserState() = _$_UserState;
}

/// @nodoc
abstract class $UserLoadingCopyWith<$Res> {
  factory $UserLoadingCopyWith(
          UserLoading value, $Res Function(UserLoading) then) =
      _$UserLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserLoadingCopyWithImpl<$Res> extends _$UserStateCopyWithImpl<$Res>
    implements $UserLoadingCopyWith<$Res> {
  _$UserLoadingCopyWithImpl(
      UserLoading _value, $Res Function(UserLoading) _then)
      : super(_value, (v) => _then(v as UserLoading));

  @override
  UserLoading get _value => super._value as UserLoading;
}

/// @nodoc

class _$UserLoading implements UserLoading {
  const _$UserLoading();

  @override
  String toString() {
    return 'UserState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is UserLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() loading,
    required TResult Function() logged,
    required TResult Function() passwordUpdated,
    required TResult Function(String? error, List<String>? errors, Object? data)
        error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UserState value) $default, {
    required TResult Function(UserLoading value) loading,
    required TResult Function(UserLogged value) logged,
    required TResult Function(PasswordUpdated value) passwordUpdated,
    required TResult Function(UserError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(_UserState value)? $default, {
    TResult Function(UserLoading value)? loading,
    TResult Function(UserLogged value)? logged,
    TResult Function(PasswordUpdated value)? passwordUpdated,
    TResult Function(UserError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UserState value)? $default, {
    TResult Function(UserLoading value)? loading,
    TResult Function(UserLogged value)? logged,
    TResult Function(PasswordUpdated value)? passwordUpdated,
    TResult Function(UserError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class UserLoading implements UserState {
  const factory UserLoading() = _$UserLoading;
}

/// @nodoc
abstract class $UserLoggedCopyWith<$Res> {
  factory $UserLoggedCopyWith(
          UserLogged value, $Res Function(UserLogged) then) =
      _$UserLoggedCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserLoggedCopyWithImpl<$Res> extends _$UserStateCopyWithImpl<$Res>
    implements $UserLoggedCopyWith<$Res> {
  _$UserLoggedCopyWithImpl(UserLogged _value, $Res Function(UserLogged) _then)
      : super(_value, (v) => _then(v as UserLogged));

  @override
  UserLogged get _value => super._value as UserLogged;
}

/// @nodoc

class _$UserLogged implements UserLogged {
  const _$UserLogged();

  @override
  String toString() {
    return 'UserState.logged()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is UserLogged);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() loading,
    required TResult Function() logged,
    required TResult Function() passwordUpdated,
    required TResult Function(String? error, List<String>? errors, Object? data)
        error,
  }) {
    return logged();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
  }) {
    return logged?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
    required TResult orElse(),
  }) {
    if (logged != null) {
      return logged();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UserState value) $default, {
    required TResult Function(UserLoading value) loading,
    required TResult Function(UserLogged value) logged,
    required TResult Function(PasswordUpdated value) passwordUpdated,
    required TResult Function(UserError value) error,
  }) {
    return logged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(_UserState value)? $default, {
    TResult Function(UserLoading value)? loading,
    TResult Function(UserLogged value)? logged,
    TResult Function(PasswordUpdated value)? passwordUpdated,
    TResult Function(UserError value)? error,
  }) {
    return logged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UserState value)? $default, {
    TResult Function(UserLoading value)? loading,
    TResult Function(UserLogged value)? logged,
    TResult Function(PasswordUpdated value)? passwordUpdated,
    TResult Function(UserError value)? error,
    required TResult orElse(),
  }) {
    if (logged != null) {
      return logged(this);
    }
    return orElse();
  }
}

abstract class UserLogged implements UserState {
  const factory UserLogged() = _$UserLogged;
}

/// @nodoc
abstract class $PasswordUpdatedCopyWith<$Res> {
  factory $PasswordUpdatedCopyWith(
          PasswordUpdated value, $Res Function(PasswordUpdated) then) =
      _$PasswordUpdatedCopyWithImpl<$Res>;
}

/// @nodoc
class _$PasswordUpdatedCopyWithImpl<$Res> extends _$UserStateCopyWithImpl<$Res>
    implements $PasswordUpdatedCopyWith<$Res> {
  _$PasswordUpdatedCopyWithImpl(
      PasswordUpdated _value, $Res Function(PasswordUpdated) _then)
      : super(_value, (v) => _then(v as PasswordUpdated));

  @override
  PasswordUpdated get _value => super._value as PasswordUpdated;
}

/// @nodoc

class _$PasswordUpdated implements PasswordUpdated {
  const _$PasswordUpdated();

  @override
  String toString() {
    return 'UserState.passwordUpdated()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is PasswordUpdated);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() loading,
    required TResult Function() logged,
    required TResult Function() passwordUpdated,
    required TResult Function(String? error, List<String>? errors, Object? data)
        error,
  }) {
    return passwordUpdated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
  }) {
    return passwordUpdated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
    required TResult orElse(),
  }) {
    if (passwordUpdated != null) {
      return passwordUpdated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UserState value) $default, {
    required TResult Function(UserLoading value) loading,
    required TResult Function(UserLogged value) logged,
    required TResult Function(PasswordUpdated value) passwordUpdated,
    required TResult Function(UserError value) error,
  }) {
    return passwordUpdated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(_UserState value)? $default, {
    TResult Function(UserLoading value)? loading,
    TResult Function(UserLogged value)? logged,
    TResult Function(PasswordUpdated value)? passwordUpdated,
    TResult Function(UserError value)? error,
  }) {
    return passwordUpdated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UserState value)? $default, {
    TResult Function(UserLoading value)? loading,
    TResult Function(UserLogged value)? logged,
    TResult Function(PasswordUpdated value)? passwordUpdated,
    TResult Function(UserError value)? error,
    required TResult orElse(),
  }) {
    if (passwordUpdated != null) {
      return passwordUpdated(this);
    }
    return orElse();
  }
}

abstract class PasswordUpdated implements UserState {
  const factory PasswordUpdated() = _$PasswordUpdated;
}

/// @nodoc
abstract class $UserErrorCopyWith<$Res> {
  factory $UserErrorCopyWith(UserError value, $Res Function(UserError) then) =
      _$UserErrorCopyWithImpl<$Res>;
  $Res call({String? error, List<String>? errors, Object? data});
}

/// @nodoc
class _$UserErrorCopyWithImpl<$Res> extends _$UserStateCopyWithImpl<$Res>
    implements $UserErrorCopyWith<$Res> {
  _$UserErrorCopyWithImpl(UserError _value, $Res Function(UserError) _then)
      : super(_value, (v) => _then(v as UserError));

  @override
  UserError get _value => super._value as UserError;

  @override
  $Res call({
    Object? error = freezed,
    Object? errors = freezed,
    Object? data = freezed,
  }) {
    return _then(UserError(
      error: error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
      errors: errors == freezed
          ? _value.errors
          : errors // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      data: data == freezed ? _value.data : data,
    ));
  }
}

/// @nodoc

class _$UserError implements UserError {
  const _$UserError({this.error, this.errors, this.data});

  @override
  final String? error;
  @override
  final List<String>? errors;
  @override
  final Object? data;

  @override
  String toString() {
    return 'UserState.error(error: $error, errors: $errors, data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserError &&
            const DeepCollectionEquality().equals(other.error, error) &&
            const DeepCollectionEquality().equals(other.errors, errors) &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(error),
      const DeepCollectionEquality().hash(errors),
      const DeepCollectionEquality().hash(data));

  @JsonKey(ignore: true)
  @override
  $UserErrorCopyWith<UserError> get copyWith =>
      _$UserErrorCopyWithImpl<UserError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() loading,
    required TResult Function() logged,
    required TResult Function() passwordUpdated,
    required TResult Function(String? error, List<String>? errors, Object? data)
        error,
  }) {
    return error(this.error, errors, data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
  }) {
    return error?.call(this.error, errors, data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error, errors, data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_UserState value) $default, {
    required TResult Function(UserLoading value) loading,
    required TResult Function(UserLogged value) logged,
    required TResult Function(PasswordUpdated value) passwordUpdated,
    required TResult Function(UserError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(_UserState value)? $default, {
    TResult Function(UserLoading value)? loading,
    TResult Function(UserLogged value)? logged,
    TResult Function(PasswordUpdated value)? passwordUpdated,
    TResult Function(UserError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_UserState value)? $default, {
    TResult Function(UserLoading value)? loading,
    TResult Function(UserLogged value)? logged,
    TResult Function(PasswordUpdated value)? passwordUpdated,
    TResult Function(UserError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class UserError implements UserState {
  const factory UserError({String? error, List<String>? errors, Object? data}) =
      _$UserError;

  String? get error;
  List<String>? get errors;
  Object? get data;
  @JsonKey(ignore: true)
  $UserErrorCopyWith<UserError> get copyWith =>
      throw _privateConstructorUsedError;
}
